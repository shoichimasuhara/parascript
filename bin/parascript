#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Parascript.pm"} = <<'PARASCRIPT';
  package Parascript;
  use strict;
  use warnings;
  
  our $VERSION    = '0.0.1';
  
  use Getopt::Long;
  use Pod::Usage;
  use MIME::Base64;
  use Parallel::ForkManager;
  use Symbol;
  use Net::SSH qw/ sshopen3 /;
  use Term::ANSIColor qw/ colored /;
  use Path::Class qw/ dir file /;
  use Data::Dumper;
  
  use Parascript::ResultBucket;
  
  $Term::ANSIColor::AUTORESET = 1;
  
  sub run{
      my $self    = __PACKAGE__->_new;
      $self
          ->_init
          ->_exec
      ;
  }
  
  sub _new{
      my $class   = shift;
      my $self    = bless {
          _maxproc            => 20,
          _result_bucket      => Parascript::ResultBucket->new(1024 * 1024),
          _list_stdin         => -p STDIN ? 1 : undef,
          _list_file          => undef,
          _user               => $ENV{USER}, 
          _hosts              => undef,
          _single_host        => undef,
          _sudo               => undef,
          _sudo_passwd        => undef,
          _command            => undef,
          _script_file        => undef,
          _interpreter        => undef,
          _output_dir         => undef,
          _show_status        => 1,
          _ng_list_file       => undef,
          _no_hostname        => undef,
          _show_out           => undef,
          _show_err           => undef,
          _host               => undef,
          _status             => undef,
          _out                => '',
          _err                => '',
          _quiet              => undef,
          _timeout            => 10,
          _ssh_key            => undef,
          _ssh_config         => '/etc/ssh/ssh_config,~/.ssh/config',
          _ssh_known_hosts    => undef
      }, $class;
      return $self;
  }
  
  sub _init{
      my $self    = shift;
      $self
          ->_get_options
          ->_check_options
          ->_read_list
          ->_get_sudo_passwd
          ->_create_command_line
      ;
      return $self;
  }
  
  =head1 SYNOPSIS
  
  parascript -h
  parascript --help
  parascript [OPTION] ...
  
   Options:
      -h --help                               display a summary of this command 
      -l --list LIST_FILE                     host list file          (You should give this script the host list
      -1 --single SINGLE_HOST                 single host              from STDIN or file or single host)
      -c --command COMMAND                    command                 (You can choice single command or script file)
      --script SCRIPT_FILE                    script file
      -i --interpreter PATH_TO_INTERPRETER    interpreter            
      --sudo                                  to execute with sudo
      -o --output PUTH_TO_OUTPUT_DIR          output directory        (Make log files like $HOST.out and $HOST.err)
      -t --test                               show command status     (Display only status OK and NG)
      --ng PATH_TO_NG_LIST_FILE               file to save NG list    (Default not saved)
      -e --error                              show error
      -n --nohostname                         don't show hostname
      -q --quiet                              don't show at all
      -m --maxproc MAX_PROC_NUM               max proccess            (Default 20)
      -u --user USER_NAME                     ssh user name
      --ssh-key SSH_PRIVATE_KEY
      --ssh-config SSH_CONFIG,SSH_CONFIG,,,
      --ssh-known-hosts SSH_KNOWN_HOSTS_FILE
  =cut
  
  sub _get_options{
      my $self    = shift;
      GetOptions(
          "h|help"            => \$self->{_help},
          "l|list=s"          => \$self->{_list_file},
          "1|single=s"        => \$self->{_single_host},
          "c|command=s"       => \$self->{_command},
          "s|script=s"        => \$self->{_script_file},
          "i|interpreter=s"   => \$self->{_interpreter},
          "nostatus"          => \$self->{_no_status},
          "sudo"              => \$self->{_sudo},
          "log=s"             => \$self->{_output_dir},
          "t|test"            => \$self->{_show_status},
          "ng=s"              => \$self->{_ng_list_file},
          "o|stdout"          => \$self->{_show_out},
          "e|stderr"          => \$self->{_show_err},
          "n|nohostname"      => \$self->{_no_hostname},
          "q|quiet"           => \$self->{_quiet},
          "m|maxproc=i"       => \$self->{_maxproc},
          "u|user=s"          => \$self->{_user},
          "timeout=i"         => \$self->{_timeout},
          "ssh-key=s"         => \$self->{_ssh_key},
          "ssh-config=s"      => \$self->{_ssh_config},
          "ssh-known-hosts=s" => \$self->{_ssh_known_hosts},
      ) or pod2usage(2);
      $self->{_show_status}   = undef if $self->{_no_status};
      return $self;
  }
  
  sub _check_options{
      my $self    = shift;
  
      pod2usage if $self->{_help};
  
      $self->_file_check($_) foreach qw/ list script /;
      $self->_dir_check($_) foreach qw/ output /;
  
      if(
          $self->{_script_file}   and
          ! $self->{_interpreter}
      ){
          unless($self->_get_interpreter){
              print "\nYou should set the path of the interpreter\n\n";
              pod2usage;
          }
      }
  
      pod2usage unless
          ($self->{_list_stdin} or $self->{_list_file} or $self->{_single_host})      and
          ($self->{_command} or ($self->{_script_file} and $self->{_interpreter}))
      ;
  
      return $self;
  }
  
  sub _file_check{
      my ($self, $type)   = @_;
      my $key         = '_' . $type . '_file';
      die $type . ' file "' . $self->{$key} . '" is not a file'
                              if $self->{$key} && ! -f $self->{$key};
  }
  
  sub _dir_check{
      my ($self, $type)   = @_;
      my $key         = '_' . $type . '_dir';
      die $type . ' directory "' . $self->{$key} . '" is not directory'
                              if $self->{$key} && ! -d $self->{$key};
  }
  
  sub _get_interpreter{
      my $self    = shift;
      open my $script, '<', $self->{_script_file};
      my $shebang = <$script>;
      close $script;
      if($shebang =~ /^#!/){
          $shebang    =~ s/^#!//g;
          chomp $shebang;
          $self->{_interpreter}   = $shebang;
          return 1;
      }else{
          return 0;
      }
  }
  
  sub _read_list{
      my $self    = shift;
      $self->_read_list_from_file                 if $self->{_list_file};
      $self->_read_list_from_stdin                if $self->{_list_stdin};
      $self->{_hosts} = [$self->{_single_host}]   if $self->{_single_host};
      return $self;
  }
  
  sub _read_list_from_stdin{
      my $self    = shift;
      my @list    = ();
      while(<STDIN>){
          $_  =~ s/^\s*(.*?)\s*$/$1/;
          if($_ =~ /\s/){
              $_  =~ s/\s\+/ /g;
              push @list, split(' ', $_);
          }else{
              push @list, $_;
          }
      }
      close STDIN;
      $self->{_hosts} = [@list];
  }
  
  sub _read_list_from_file{
      my $self    = shift;
      my @list    = ();
      open my $in, '<', $self->{_list_file};
      while(<$in>){
          chomp $_;
          push @list, $_;
      }
      close $in;
      $self->{_hosts} = [@list];
  }
  
  sub _get_sudo_passwd{
      my $self    = shift;
  
      if($self->{_sudo}){
          $|  = 1;
          print STDERR "Please input your password for sudo > ";
          $|  = 0;
          open TTY, '<', '/dev/tty';
          system 'stty -echo';
          chomp(my $passwd    = <TTY>);
          system 'stty echo';
          close TTY;
          print "\n";
          $self->{_sudo_passwd}   = $passwd;
      }
      return $self;
  }
  
  sub _create_command_line{
      my $self    = shift;
  
      my $base64_commands;
      if($self->{_script_file}){
          $base64_commands    = encode_base64($self->_read_script);
      }else{
          $base64_commands    = encode_base64($self->{_command});
      }
  
      $self->{_interpreter}   = 'bash' unless $self->{_interpreter};
      $self->{_command}       =
              'echo "' . $base64_commands .
              '"|base64 -d -i|' .
              $self->{_interpreter}
      ;
      $self->{_command}   = "bash -c '" . $self->{_command} . "'";
      $self->{_command}   = 'sudo -S ' . $self->{_command} if $self->{_sudo};
      return $self;
  }
  
  sub _read_script{
      my $self    = shift;
      open my $in, '<', $self->{_script_file};
      read $in, my $script, -s $self->{_script_file};
      close $in;
      return $script;
  }
  
  sub _exec{
      my $self    = shift;
  
  
      my $pm      = Parallel::ForkManager->new($self->{_maxproc});
      $|=0;
      foreach my $host (@{$self->{_hosts}}){
          $pm->start and next;
  
          $self->{_host}  = $host;
  
          my $buff    = '';
          $buff       .= $self->_make_header;
          $self->_exec_ssh;
          $buff       .= $self->_make_contents;
          $self->_logging;
  
          unless($self->{_quiet}){
              $|=1;
              print $buff;
              $|=0;
          }
          unless($self->{_status}){
              $self->{_result_bucket}->add('NG', $self->{_host});
          }
          $pm->finish;
      }
      $pm->wait_all_children;
      $self->_display_ng_hosts;
      $self->{_result_bucket}->close;
  }
  
  sub _exec_ssh{
      my $self    = shift;
  
      $self->_init_ssh;
  
      my ($in, $out, $err)    = (gensym, gensym, gensym);
      my $pid = sshopen3(
          $self->{_user}.'@'.$self->{_host},
          $in, $out, $err,
          $self->{_command}
      );
  
      print $in $self->{_sudo_passwd} . "\n" if $self->{_sudo};
      close $in;
  
      while(<$out>){
          chomp $_; 
          $self->{_out}   .= $_ . "\n";
      }
      close $out;
  
      while(<$err>){
          chomp $_;
          $self->{_err}   .= $_ . "\n";
      }
      close $err; 
  
      waitpid $pid, 0;
      $self->{_status}    = $?>>8 ? 0 : 1; 
  }
  
  sub _init_ssh{
      my $self    = shift;
      my @ssh_options = ();
      foreach my $ssh_config (split(',', $self->{_ssh_config})){
          $ssh_config = $self->_expand_tilde($ssh_config);
          push @ssh_options, ('-F', $ssh_config)  if -f $ssh_config;
      }
      if($self->{_ssh_key}){
          my $ssh_key = $self->_expand_tilde($self->{_ssh_key});
          push @ssh_options, ('-i', $ssh_key)     if -f $ssh_key;
      }
      if($self->{_ssh_known_hosts}){
          my $ssh_known_hosts = $self->_expand_tilde($self->{_ssh_known_hosts});
          push @ssh_options, ('-o', 'UserKnownHostsFile=' . $ssh_known_hosts);
      }
      push @ssh_options, (
          '-T',
          '-o', 'BatchMode=yes',
          '-o', 'StrictHostKeyChecking=no',
          '-o', 'ConnectTimeout=' . $self->{_timeout}
      );
      @Net::SSH::ssh_options  = @ssh_options;
  }
  
  sub  _expand_tilde{
      my ($self, $path)   = @_;
      $path =~ s{
        ^ ~             # find a leading tilde
        (               # save this in $1
            [^/]        # a non-slash character
                  *     # repeated 0 or more times (0 means me)
        )
      }{
        $1
            ? (getpwnam($1))[7]
            : ( $ENV{HOME} || $ENV{LOGDIR} )
      }ex;
      return $path;
  }
  
  sub _make_header{
      my $self    = shift;
      my $buff    = '';
      $buff       = colored('### ' . $self->{_host} . " ##############################\n", 'BLUE')
          if ($self->{_show_out} or $self->{_show_err}) and !$self->{_no_hostname};
      return $buff;
  }
  
  sub _make_contents{
      my $self    = shift;
      my $buff    = '';
      if($self->{_show_status}){ 
          $buff   .= $self->{_host} . "\t";
          if($self->{_status}){
              $buff   .= colored("OK\n", "YELLOW");
          }else{
              $buff   .= colored("NG\n", "RED");
          }
      }
      if($self->{_show_out}){
          $buff   .= colored("==STDOUT====\n", 'YELLOW') if $self->{_show_err};
          $buff   .= $self->{_out};
          $buff   .= "\n" unless $self->{_no_hostname};
      }
      if($self->{_show_err}){
          $buff   .= colored("==STDERR====\n", 'RED');
          $buff   .= $self->{_err};
          $buff   .= "\n" unless $self->{_no_hostname};
      }
      return $buff;
  }
  
  sub _logging{
      my $self    = shift;
      if($self->{_output_dir} and -d $self->{_output_dir}){
          foreach my $type (qw/ out err /){
              my $io  = dir($self->{_output_dir})->file($self->{_host} . '.' . $type)->open('a');
              $io->print($self->{'_' . $type});
              $io->close;
          }
      }
      if($self->{_ng_list_file}){
          unless($self->{_status}){
              my $io  = file($self->{_ng_list_file})->open('a');
              $io->blocking(1);
              $io->print($self->{_host} . "\n");
              $io->close;
          }
      }
  }
  
  sub _display_ng_hosts{
      my $self        = shift;
      my $ng_hosts    = $self->{_result_bucket}->dump->{NG};
      if($ng_hosts and ref $ng_hosts eq 'ARRAY'){
          my $buff    = '';
          $buff       .= colored("==NG HOSTS====\n", 'RED');
          $buff       .= join("\n", @{$ng_hosts});
          $buff       .= "\n";
          print STDERR $buff;
      }
  }
  
  1;
PARASCRIPT

$fatpacked{"Parascript/ResultBucket.pm"} = <<'PARASCRIPT_RESULTBUCKET';
  package Parascript::ResultBucket;
  use strict;
  use warnings;
  use IPC::SysV   qw/ IPC_CREAT IPC_EXCL IPC_RMID SETVAL ftok /;
  use Storable    qw/ nfreeze thaw /;
  use Time::HiRes qw/ usleep /;
  use constant MAX_RETRY  => 1024;
  
  sub new{
      my ($class, $size)  = @_;
      die("Data Size is requierd") unless $size;
      my $self    = bless {
          _size   => $size
      }, $class;
      $self->{_key}   = $self->_get_key;
      $self->{_shmid} = $self->_get_shm;
      $self->{_semid} = $self->_get_sem;
      $self->_clear;
      return $self;
  }
  
  sub add{
      my ($self, $key, $value)    = @_;
      $self->_lock;
      my $buff        = $self->_read;
      $buff->{$key}   = [] unless $buff->{$key};
      push(@{$buff->{$key}}, $value);
      $self->_write($buff);
      $self->_unlock;
  }
  
  sub set{
      my ($self, $key, $value)    = @_;
      $self->_lock;
      my $buff    = $self->_read;
      $buff->{$key}   = $value;
      $self->_write($buff);
      $self->_unlock;
  }
  
  sub dump{
      my $self    = shift;
      $self->_lock;
      my $buff    = $self->_read;
      $self->_unlock;
      return $buff;
  }
  
  sub close{
      my $self    = shift;
      $self->_destroy_sem;
      $self->_destroy_shm; 
  }
  
  sub _read{
      my $self    = shift;
      my $data;
      shmread($self->{_shmid}, $data, 0, $self->{_size}) or die;
      return thaw($data);
  }
  
  sub _write{
      my ($self, $data)   = @_;
      $data   = nfreeze($data);
      shmwrite($self->{_shmid}, $data, 0, length($data)) or die;
  }
  
  sub _lock{
      my $self    = shift;
      my $op  = pack("sss", 0, -1, 0);
      foreach (1 .. MAX_RETRY){
          semop($self->{_semid}, $op) and last;
          usleep 1;
      }
  }
  
  sub _unlock{
      my $self    = shift;
      my $op  = pack("sss", 0, 1, 0);
      foreach (1 .. MAX_RETRY){
         semop($self->{_semid}, $op) and last;
          usleep 1;
      }
  }
  
  sub _get_key{
      return ftok($0, $$);
  }
  
  sub _get_shm{
      my $self    = shift;
      return shmget(
          $self->{_key},
          $self->{_size},
          IPC_CREAT | 0644
      ) or die($!);
  }
  
  sub _get_sem{
      my $self    = shift;
      my $semid   = semget(
          $self->{_key},
          1,
          0644|&IPC_CREAT|IPC_EXCL
      );
      if(defined($semid)){
          semctl($semid, 0, &SETVAL, 1) or die($!);
      }else{
          $semid  = semget(
              $self->{_key},
              1,
              0644
          ) or die($!);
      }
      return $semid;
  }
  
  sub _clear{
      my $self    = shift;
      $self->_lock;
      $self->_write({});
      $self->_unlock;
  }
  
  sub _destroy_sem{
      my $self    = shift;
      semctl($self->{_semid}, 0, IPC_RMID, 0);
  }
  
  sub _destroy_shm{
      my $self    = shift;
      shmctl($self->{_shmid}, 0, IPC_RMID);
  }
  
  1;
PARASCRIPT_RESULTBUCKET

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
use strict;
use warnings;
use Parascript;

Parascript->run;
